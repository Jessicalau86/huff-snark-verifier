/// @title Huff Snark Verifier
/// @notice TODO
///
///         This contract is based off of Verification.sol by Christian Reitwiessner.
///
/// @author clabby <https://github.com/clabby>

/// TODO: Use safe math. Alternatively, we can verify that the input to
///       `verify` & `verifyProof` is valid to save gas. Will need to do
///       some safety documentation if we go that route.

/// @notice Generator point for G1
#define table G1 = {
    0x0000000000000000000000000000000000000000000000000000000000000001
    0x0000000000000000000000000000000000000000000000000000000000000002
}

/// @notice Generator point for G2
#define table G2 = {
    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2
    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed
    0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b
    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa
}

/// @notice The prime q in the base field F_q for G1
#define constant Q = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47

/// @notice The snark scalar field.
#define constant SNARK_SCALAR = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001

/// @notice The location of the `IC` portion of the verification key's length in memory.
#define constant IC_LEN_PTR = 0x1e0

/// @notice The location of the first element of the `IC` portion of the verification key in memory.
#define constant IC_PTR = 0x200

/// @notice The location of the second element of the `IC` portion of the verification key in memory.
#define constant IC_PTR_PLUS_1 = 0x220

/// @notice The location of `vk_x` in memory
#define constant VK_X_PTR = 0x2e0

/// @dev Stores the generator point of G1 in memory at ptr.
#define macro P1(ptr) = {
    // Input stack:        []

    __tablestart(G1)    // [G1_start]
    __tablesize(G1)     // [G1_size, G1_start]
    <ptr>               // [0x00, G1_size, G1_start]
    codecopy            // []

    // Return stack:       []
}

/// @dev Stores the generator point of G2 in memory at ptr.
#define macro P2(ptr) = {
    // Input stack:        []

    __tablestart(G2)    // [G2_start]
    __tablesize(G2)     // [G2_size, G2_start]
    <ptr>               // [0x00, G2_size, G2_start]
    codecopy            // []

    // Return stack:       []
}

/// @param `ptr` - Memory pointer to the input point
/// @dev Writes the negation of the passed point to memory at `ptr`
///
/// - SAFETY:
///      Overwrites memory from [ptr:ptr+0x40]
#define macro NEGATE(ptr) = {
    // Input stack:        []

    <ptr>               // [g1_point_ptr]
    dup1 mload          // [p_x, g1_point_ptr]
    dup2 0x20 add       // [g1_point_ptr + 0x20, p_x, g1_point_ptr]
    mload               // [p_y, p_x, g1_point_ptr]

    dup1 iszero         // [p_y == 0, p_y, p_x, g1_point_ptr]
    dup3 iszero         // [p_x == 0, p_y == 0, p_y, p_x, g1_point_ptr]
    and                 // [p_x == 0 & p_y == 0, p_y, p_x, g1_point_ptr]

    // The passed point is already zero, do nothing.
    clean_stack jumpi   // [p_y, p_x, g1_point_ptr]

    [Q] swap1 mod       // [p_y % Q, p_x, g1_point_ptr]
    [Q] sub             // [Q - (p_y % Q), p_x, g1_point_ptr]
    dup3 0x20 add       // [g1_point_ptr + 0x20, Q - (p_y % Q), p_x, g1_point_ptr]
    mstore              // [p_x, g1_point_ptr]
    swap1 mstore        // []

    continue jump       // []

    clean_stack:
        pop pop pop
    continue:

    // Return stack:       []
}

/// @param `ptr_a` - Memory pointer to the input point `a` (64 bytes).
/// @param `ptr_b` - Memory pointer to the input point `b` (64 bytes).
/// @dev Calls the ecAdd precompile with the G1 points `a` and `b`. Writes
///      64 byte result to memory @ VK_X_PTR (0x2e0).
/// 
/// - SAFETY:
///      Overwrites scratch memory from [0x00:0x80]
///      Overwrites vk_x in memory from [VK_X_PTR:VK_X_PTR+0x40]
#define macro ADDITION() = takes (2) {
    // Input stack:        [ptr_b, ptr_a]

    // Load `b` onto the stack
    dup1 mload          // [b_0, ptr_b, ptr_a]
    swap1 0x20 add      // [ptr_b + 0x20, b_0, ptr_a]
    mload               // [b_1, b_0, ptr_a]

    // Load `a` onto the stack
    swap2               // [ptr_a, b_0, b_1]
    dup1 0x20 add       // [ptr_a + 0x20, ptr_a, b_0, b_1]
    mload swap1         // [ptr_a, a_1, b_0, b_1]
    mload               // [a_0, a_1, b_0, b_1]

    // Store `a` (64 bytes) in scratch space @ 0x00
    0x00 mstore         // [a_1, b_0, b_1]
    0x20 mstore         // [b_0, b_1]
    // Store `b` (64 bytes) in scratch space @ 0x40
    0x40 mstore         // [b_1]
    0x60 mstore         // []

    // The `ADDITION` macro is *only* used for the linear combination on the
    // vk_x g1 point in the `VERIFY` macro. Because of this, the output memory
    // location of the staticcall is hardcoded to 0x2E0. 
    0x40 [VK_X_PTR]     // [vk_x_ptr, 0x40]
    0x80 0x00           // [0x00, 0x80, vk_x_ptr, 0x40]
    // TODO: Sub 2000 from gas / add invalid op on failure?
    0x06 gas            // [gas, ec_add_precompile, out_ptr, 0x80, out_ptr, 0x40]
    staticcall          // [success]
    continue jumpi      // []

    // TODO: Custom revert message on failure
    0x00 dup1 revert

    continue:

    // Return stack:       []
}

/// @param `ptr_a` - Memory pointer to the input point `a` (64 bytes).
/// @dev Calls the ecAdd precompile with the G1 points `a` and `b`. Writes
///      64 byte result to memory @ VK_X_PTR (0x2e0).
///      
///      This macro is a secondary version of `ADDITION` that is only used in the
///      linear combination loop. The result of a `SCALAR_MUL` call is always
///      the second operand of the `ADDITION` call within the loop, and we
///      use this macro so that we don't have to re-store the `SCALAR_MUL`
///      result in scratch space.
/// 
/// - SAFETY:
///      Overwrites scratch memory from [0x40:0x80]
///      Overwrites vk_x in memory from [VK_X_PTR:VK_X_PTR+0x40]
#define macro ADDITION_2() = takes (1) {
    // Input stack:        [ptr_a]

    // Load `a` onto the stack
    dup1 0x20 add       // [ptr_a + 0x20, ptr_a]
    mload swap1         // [ptr_a, a_1]
    mload               // [a_0, a_1]

    // Store `a` (64 bytes) in scratch space @ 0x40
    // (the result of a `SCALAR_MUL` call is already in 0x00:0x40)
    0x40 mstore         // [a_1]
    0x60 mstore         // []

    // The `ADDITION_2` macro is *only* used for the linear combination on the
    // vk_x g1 point in the `VERIFY` macro. Because of this, the output memory
    // location of the staticcall is hardcoded to 0x2E0. 
    0x40 [VK_X_PTR]     // [vk_x_ptr, 0x40]
    0x80 0x00           // [0x00, 0x80, vk_x_ptr, 0x40]
    // TODO: Sub 2000 from gas / add invalid op on failure?
    0x06 gas            // [gas, ec_add_precompile, out_ptr, 0x80, out_ptr, 0x40]
    staticcall          // [success]
    continue jumpi      // []

    // TODO: Custom revert message on failure
    0x00 dup1 revert

    continue:

    // Return stack:       []
}

/// @param `ptr_a` - Memory pointer to the input point `a` (64 bytes).
/// @param `scalar_ptr` - Memory pointer to the input `scalar` (32 bytes).
/// @dev Calls the ecMul precompile with the G1 point `a` and the `scalar`.
///      Writes 64 byte result to scratch memory @ 0x00.
#define macro SCALAR_MUL() = takes (2) {
    // Input stack:        [ptr_a, scalar_ptr]

    dup1 0x20 add       // [ptr_a + 0x20, ptr_a, scalar_ptr]
    mload               // [a_1, ptr_a, scalar_ptr]
    swap1 mload         // [a_0, a_1, scalar_ptr]
    swap2 mload         // [scalar, a_1, a_0]

    0x40 mstore         // [a_1, a_0]
    0x20 mstore         // [a_0]
    0x00 mstore         // []

    0x40 0x00           // [0x00, 0x40]
    0x60 dup2           // [0x00, 0x60, 0x00, 0x40]
    // TODO: Sub 2000 from gas / add invalid op on failure?
    0x07 gas            // [gas, ec_add_precompile, out_ptr, 0x60, out_ptr, 0x40]
    staticcall          // [success]
    continue jumpi      // []

    // TODO: Custom revert message on failure
    0x00 dup1 revert
    
    continue:

    // Return stack:       []
}

// We only need paringProd4 for the pairing check.
// #define macro PAIRING(ptr_p1, ptr_p2) = {
//     <ptr_p1> mload
//     <ptr_p2> mload
//     eq
// }

// ...

/// @notice The verification key of the SNARK.
/// @dev This value is filled by the `huffv` binary, and it is packed with no
///      periphery information (i.e. "AlphaBetaGammaDeltaIC"). See the comment
///      of `MSTORE_VKEY` for more information.
#define table VKEY {
    // {{placeholder}}
}

/// @notice Writes the verification key to memory at `ptr`
/// @dev The memory layout is as follows:
#define macro MSTORE_VKEY(ptr) = {
    // Input stack:        []

    __tablestart(VKEY)  // [VKEY_start]
    __tablesize(VKEY)   // [VKEY_size, VKEY_start]
    <ptr>               // [0x00, VKEY_size, VKEY_start]
    codecopy            // []

    // Return stack:       []
}

/// - SAFETY:
///     MEMORY RESERVATIONS:
///     [0x00:0x80] - Scratch Space
///     [0x80:0x2E0] - Verification key
///     [0x2E0:0x320] - vk_x
#define macro VERIFY(input_ptr) = {
    // Stores the verification key in memory [0x80:0x2E0]
    MSTORE_VKEY(0x00)       // []
    // Push the snark scalar to the stack
    [SNARK_SCALAR]          // [snark_scalar]

    <input_ptr> mload       // [input_len, snark_scalar]
    0x01 add                // [input_len + 1, snark_scalar]
    // TODO: IC length can be dynamic, I think.
    0x02 eq                 // [input_len + 1 == 2, snark_scalar]
    start_verify jumpi      // [snark_scalar]

    fail:
        // TODO: Custom revert message on failure
        0x00 dup1 revert

    // input_len + 1 == IC_length
    start_verify:
        // Compute the linear combination vk_x
        // 0x260-0x2A0 reserved for the result.
        <input_ptr>         // [input_ptr, snark_scalar]
        0x20 add            // [input_ptr + 0x20, snark_scalar]
        <input_ptr> mload   // [input_len, input_ptr + 0x20, snark_scalar]
        0x00                // [loop_offset, input_len, input_ptr + 0x20, snark_scalar]
        linear_combination:
            // Check if the loop is complete
            dup1 dup3       // [input_len, loop_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]  
            gt iszero       // [input_len <= loop_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            post_loop jumpi // [loop_offset, input_len, input_ptr + 0x20, snark_scalar]

            // Load input[i] onto the stack
            dup1 dup4 add   // [input_ptr + 0x20 + loop_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            dup1            // [cur_input_offset, cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            mload           // [input[i], cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]

            // require(input[i] < snark_scalar)
            dup5            // [snark_scalar, input[i], cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            gt iszero       // [snark_scalar <= input[i], cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            fail jumpi      // [cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]

            // Scalar mul IC[i + 1], input[i]
            dup1            // [cur_input_offset, cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            [IC_PTR_PLUS_1] // [ic_ptr, cur_input_offset, cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            add             // [ic_ptr + cur_input_offset, cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]

            // Store scalar mul result in scratch space @ 0x00
            SCALAR_MUL()    // [loop_offset, input_len, input_ptr + 0x20, snark_scalar]

            [VK_X_PTR]      // [vk_x_ptr, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            ADDITION_2()    // [loop_offset, input_len, input_ptr + 0x20, snark_scalar]]

            // Increase loop index
            0x20 add        // [loop_offset + 0x20, input_len, input_ptr + 0x20, snark_scalar]
            // Continue combination loop
            linear_combination jump
        post_loop:
            // Add the point in IC[0] to `vk_x`
            [IC_PTR]        // [ic_ptr, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            [VK_X_PTR]      // [vk_x_ptr, ic_ptr, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            ADDITION()      // [loop_offset, input_len, input_ptr + 0x20, snark_scalar]

            // pairingProd4
}

/// @notice Verifies a SNARK proof.
/// @return `bool` True if proof is valid, false if not.
#define macro VERIFY_PROOF() = {
    MSTORE_VKEY(0x00)   // []
    [SNARK_SCALAR]      // [snark_scalar]

    // TODO
}
