/// @title Huff Snark Verifier
/// @notice TODO
///
///         This contract is based off of Verification.sol by Christian Reitwiessner.
///
/// @author clabby <https://github.com/clabby>

/// TODO: Use safe math. Alternatively, we can verify that the input to
///       `verify` & `verifyProof` is valid to save gas. Will need to do
///       some safety documentation if we go that route.

/// @notice Generator point for G1
#define table G1 = {
    0x0000000000000000000000000000000000000000000000000000000000000001
    0x0000000000000000000000000000000000000000000000000000000000000002
}

/// @notice Generator point for G2
#define table G2 = {
    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2
    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed
    0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b
    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa
}

/// @notice The prime q in the base field F_q for G1
#define constant Q = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47

/// @notice The snark scalar field.
#define constant SNARK_SCALAR = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001

/// @dev Stores the generator point of G1 in memory at ptr.
#define macro P1(ptr) = {
    // Input stack:        []

    __tablestart(G1)    // [G1_start]
    __tablesize(G1)     // [G1_size, G1_start]
    <ptr>               // [0x00, G1_size, G1_start]
    codecopy            // []

    // Return stack:       []
}

/// @dev Stores the generator point of G2 in memory at ptr.
#define macro P2(ptr) = {
    // Input stack:        []

    __tablestart(G2)    // [G2_start]
    __tablesize(G2)     // [G2_size, G2_start]
    <ptr>               // [0x00, G2_size, G2_start]
    codecopy            // []

    // Return stack:       []
}

/// @param `ptr` - Memory pointer to the input point
/// @dev Writes the negation of the passed point to memory at `ptr`
///
/// - SAFETY:
///      Overwrites memory from [ptr:ptr+0x40]
#define macro NEGATE(ptr) = {
    // Input stack:        []

    <ptr>               // [g1_point_ptr]
    dup1 mload          // [p_x, g1_point_ptr]
    dup2 0x20 add       // [g1_point_ptr + 0x20, p_x, g1_point_ptr]
    mload               // [p_y, p_x, g1_point_ptr]

    dup1 iszero         // [p_y == 0, p_y, p_x, g1_point_ptr]
    dup3 iszero         // [p_x == 0, p_y == 0, p_y, p_x, g1_point_ptr]
    and                 // [p_x == 0 & p_y == 0, p_y, p_x, g1_point_ptr]

    // The passed point is already zero, do nothing.
    clean_stack jumpi   // [p_y, p_x, g1_point_ptr]

    [Q] swap1 mod       // [p_y % Q, p_x, g1_point_ptr]
    [Q] sub             // [Q - (p_y % Q), p_x, g1_point_ptr]
    dup3 0x20 add       // [g1_point_ptr + 0x20, Q - (p_y % Q), p_x, g1_point_ptr]
    mstore              // [p_x, g1_point_ptr]
    swap1 mstore        // []

    continue jump       // []

    clean_stack:
        pop pop pop
    continue:

    // Return stack:       []
}

/// @param `ptr_a` - Memory pointer to the input point `a` (64 bytes).
/// @param `ptr_b` - Memory pointer to the input point `b` (64 bytes).
/// @param `out_ptr` - Memory pointer to write the result to (64 bytes).
/// @dev Calls the ecAdd precompile with the G1 points `a` and `b`. Writes
///      64 byte result to memory @ `out_ptr`.
///
/// - SAFETY:
///      Overwrites memory from [out_ptr:out_ptr+0x80]
#define macro ADDITION(ptr_a, ptr_b, out_ptr) = {
    // Input stack:        [ptr_a, ptr_b, out_ptr]

    // TODO: Can optimize if we ensure `a` and `b` are stored directly
    //       next to each other in memory to begin with.

    // Load `b` onto the stack
    <ptr_b> 0x20 add    // [ptr_b + 0x20]
    mload               // [b_1]
    <ptr_b> mload       // [b_0, b_1]

    // Load `a` onto the stack
    <ptr_a> 0x20 add    // [ptr_a + 0x20, b_0, b_1]
    mload               // [a_1, b_0, b_1]
    <ptr_a> mload       // [a_0, a_1, b_0, b_1]

    // Store `a` in memory @ `out_ptr`
    <out_ptr> mstore    // [a_1, b_0, b_1]
    <out_ptr> 0x20 add  // [out_ptr + 0x20, a_1, b_0, b_1]
    mstore              // [b_0, b_1]

    // Store `b` in memory @ `out_ptr + 0x40`
    <out_ptr> 0x40 add  // [out_ptr + 0x40, b_0, b_1]
    mstore              // [b_1]
    <out_ptr> 0x60 add  // [out_ptr + 0x60, b_1]
    mstore              // []

    0x40 <out_ptr>      // [out_ptr, 0x40]
    0x80 dup2           // [out_ptr, 0x80, out_ptr, 0x40]
    // TODO: Sub 2000 from gas / add invalid op on failure?
    0x06 gas            // [gas, ec_add_precompile, out_ptr, 0x80, out_ptr, 0x40]
    staticcall          // [success]
    continue jumpi      // []

    // TODO: Custom revert message on failure
    0x00 dup1 revert

    continue:

    // Return stack:       []
}

/// @param `ptr_a` - Memory pointer to the input point `a` (64 bytes).
/// @param `scalar_ptr` - Memory pointer to the input `scalar` (32 bytes).
/// @param `out_ptr` - Memory pointer to write the result to (64 bytes).
/// @dev Calls the ecMul precompile with the G1 point `a` and the `scalar.
///      Writes 64 byte result to memory @ `out_ptr`.
///
/// - SAFETY:
///      Overwrites memory from [out_ptr:out_ptr+0x60]
#define macro SCALAR_MUL(ptr_a, scalar_ptr, out_ptr) = {
    // Input stack:        []

    // TODO: Can optimize if we ensure `ptr_a` and `scalar` are stored directly
    //       next to each other in memory to begin with.

    <scalar_ptr> mload  // [scalar]
    <ptr_a> mload       // [a_0, scalar]
    <ptr_a> 0x20 add    // [ptr_a + 0x20, a_0, scalar]
    mload               // [a_1, a_0, scalar]

    <out_ptr> 0x20 add  // [out_ptr + 0x20, a_1, a_0, scalar]
    mstore              // [a_0, scalar]
    0x00 mstore         // [scalar]
    <out_ptr> 0x40 add  // [out_ptr + 0x20, scalar]
    mstore              // []

    0x40 <out_ptr>      // [out_ptr, 0x40]
    0x60 dup2           // [out_ptr, 0x60, out_ptr, 0x40]
    // TODO: Sub 2000 from gas / add invalid op on failure?
    0x07 gas            // [gas, ec_add_precompile, out_ptr, 0x60, out_ptr, 0x40]
    staticcall          // [success]
    continue jumpi      // []

    // TODO: Custom revert message on failure
    0x00 dup1 revert
    
    continue:

    // Return stack:       []
}

// #define macro PAIRING(ptr_p1, ptr_p2) = {
//     <ptr_p1> mload
//     <ptr_p2> mload
//     eq
// }

// ...

/// @notice The verification key of the SNARK.
/// @dev This value is filled by the `huffv` binary, and it is packed with no
///      periphery information (i.e. "AlphaBetaGammaDeltaIC"). See the comment
///      of `MSTORE_VKEY` for more information.
#define table VKEY {
    // {{placeholder}}
}

/// @notice Writes the verification key to memory at `ptr`
/// @dev The memory layout is as follows:
#define macro MSTORE_VKEY(ptr) = {
    // Input stack:        []

    __tablestart(VKEY)  // [VKEY_start]
    __tablesize(VKEY)   // [VKEY_size, VKEY_start]
    <ptr>               // [0x00, VKEY_size, VKEY_start]
    codecopy            // []

    // Return stack:       []
}

/// - SAFETY:
///     MEMORY RESERVATIONS:
///     [0x00:0x80] - Scratch Space
///     [0x80:0x2E0] - Verification key
///     [0x2E0:0x320] - vk_x
#define macro VERIFY(input_ptr) = {
    // Stores the verification key in memory [0x80:0x2E0]
    MSTORE_VKEY(0x00)       // []
    // Push the snark scalar to the stack
    [SNARK_SCALAR]          // [snark_scalar]

    <input_ptr> mload       // [input_len, snark_scalar]
    0x01 add                // [input_len + 1, snark_scalar]
    // TODO: IC length can be dynamic, I think.
    0x02 eq                 // [input_len + 1 == 2, snark_scalar]
    start_verify jumpi      // [snark_scalar]

    fail:
        // TODO: Custom revert message on failure
        0x00 dup1 revert

    // input_len + 1 == IC_length
    start_verify:
        // Compute the linear combination vk_x
        // 0x260-0x2A0 reserved for the result.
        <input_ptr>         // [input_ptr, snark_scalar]
        0x20 add            // [input_ptr + 0x20, snark_scalar]
        <input_ptr> mload   // [input_len, input_ptr + 0x20, snark_scalar]
        0x00                // [loop_offset, input_len, input_ptr + 0x20, snark_scalar]
        linear_combination:
            // Check if the loop is complete
            dup1 dup3       // [input_len, loop_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]  
            gt iszero       // [input_len <= loop_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            post_loop jumpi // [loop_offset, input_len, input_ptr + 0x20, snark_scalar]

            // Load input[i] onto the stack
            dup1 dup4 add   // [input_ptr + 0x20 + loop_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            dup1            // [cur_input_offset, cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            mload           // [input[i], cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]

            // require(input[i] < snark_scalar)
            dup5            // [snark_scalar, input[i], cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            gt iszero       // [snark_scalar <= input[i], cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]
            fail jumpi      // [cur_input_offset, loop_offset, input_len, input_ptr + 0x20, snark_scalar]

            // TODO: `ADDITION` needs to accept stack args
            ADDITION()

            // Increase loop index
            0x20 add        // [loop_offset + 0x20, input_len, input_ptr + 0x20, snark_scalar]
            // Continue combination loop
            linear_combination jump
        post_loop:
            // ...
}

/// @notice Verifies a SNARK proof.
/// @return `bool` True if proof is valid, false if not.
#define macro VERIFY_PROOF() = {
    MSTORE_VKEY(0x00)   // []
    [SNARK_SCALAR]      // [snark_scalar]

    // TODO
}
