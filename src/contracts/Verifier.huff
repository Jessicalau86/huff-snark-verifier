/// @title Huff Snark Verifier
/// @notice TODO
///
///         This contract is based off of Verification.sol by Christian Reitwiessner.
///
/// @author clabby <https://github.com/clabby>

/// TODO: Use safe math. Alternatively, we can verify that the input to
///       `verify` & `verifyProof` is valid to save gas. Will need to do
///       some safety documentation if we go that route.

/// @notice Generator point for G1
#define table G1 = {
    0x0000000000000000000000000000000000000000000000000000000000000001
    0x0000000000000000000000000000000000000000000000000000000000000002
}

/// @notice Generator point for G2
#define table G2 = {
    0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2
    0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed
    0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b
    0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa
}

/// @notice The prime q in the base field F_q for G1
#define constant Q = 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47

/// @notice The snark scalar field.
#define constant SNARK_SCALAR = 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001

/// @dev Stores the generator point of G1 in memory at ptr.
#define macro P1(ptr) = {
    // Input stack:        []

    __tablestart(G1)    // [G1_start]
    __tablesize(G1)     // [G1_size, G1_start]
    <ptr>               // [0x00, G1_size, G1_start]
    codecopy            // []

    // Return stack:       []
}

/// @dev Stores the generator point of G2 in memory at ptr.
#define macro P2(ptr) = {
    // Input stack:        []

    __tablestart(G2)    // [G2_start]
    __tablesize(G2)     // [G2_size, G2_start]
    <ptr>               // [0x00, G2_size, G2_start]
    codecopy            // []

    // Return stack:       []
}

/// @param `ptr` - Memory pointer to the input point
/// @dev Writes the negation of the passed point to memory at `ptr`
///
/// - SAFETY:
///      Overwrites memory from [ptr:ptr+0x40]
#define macro NEGATE(ptr) = {
    // Input stack:        []

    <ptr>               // [g1_point_ptr]
    dup1 mload          // [p_x, g1_point_ptr]
    dup2 0x20 add       // [g1_point_ptr + 0x20, p_x, g1_point_ptr]
    mload               // [p_y, p_x, g1_point_ptr]

    dup1 iszero         // [p_y == 0, p_y, p_x, g1_point_ptr]
    dup3 iszero         // [p_x == 0, p_y == 0, p_y, p_x, g1_point_ptr]
    and                 // [p_x == 0 & p_y == 0, p_y, p_x, g1_point_ptr]

    // The passed point is already zero, do nothing.
    clean_stack jumpi   // [p_y, p_x, g1_point_ptr]

    [Q] swap1 mod       // [p_y % Q, p_x, g1_point_ptr]
    [Q] sub             // [Q - (p_y % Q), p_x, g1_point_ptr]
    dup3 0x20 add       // [g1_point_ptr + 0x20, Q - (p_y % Q), p_x, g1_point_ptr]
    mstore              // [p_x, g1_point_ptr]
    swap1 mstore        // []

    continue jump       // []

    clean_stack:
        pop pop pop
    continue:

    // Return stack:       []
}

/// @param `ptr_a` - Memory pointer to the input point `a` (64 bytes).
/// @param `ptr_b` - Memory pointer to the input point `b` (64 bytes).
/// @param `out_ptr` - Memory pointer to write the result to (64 bytes).
/// @dev Calls the ecAdd precompile with the G1 points `a` and `b`. Writes
///      64 byte result to memory @ `out_ptr`.
///
/// - SAFETY:
///      Overwrites memory from [out_ptr:out_ptr+0x80]
#define macro ADDITION(ptr_a, ptr_b, out_ptr) = {
    // Input stack:        []

    // TODO: Can optimize if we ensure `a` and `b` are stored directly
    //       next to each other in memory to begin with.

    // Load `b` onto the stack
    <ptr_b> 0x20 add    // [ptr_b + 0x20]
    mload               // [b_1]
    <ptr_b> mload       // [b_0, b_1]

    // Load `a` onto the stack
    <ptr_a> 0x20 add    // [ptr_a + 0x20, b_0, b_1]
    mload               // [a_1, b_0, b_1]
    <ptr_a> mload       // [a_0, a_1, b_0, b_1]

    // Store `a` in memory @ `out_ptr`
    <out_ptr> mstore    // [a_1, b_0, b_1]
    <out_ptr> 0x20 add  // [out_ptr + 0x20, a_1, b_0, b_1]
    mstore              // [b_0, b_1]

    // Store `b` in memory @ `out_ptr + 0x40`
    <out_ptr> 0x40 add  // [out_ptr + 0x40, b_0, b_1]
    mstore              // [b_1]
    <out_ptr> 0x60 add  // [out_ptr + 0x60, b_1]
    mstore              // []

    0x40 <out_ptr>      // [out_ptr, 0x40]
    0x80 dup2           // [out_ptr, 0x80, out_ptr, 0x40]
    // TODO: Sub 2000 from gas / add invalid op on failure?
    0x06 gas            // [gas, ec_add_precompile, out_ptr, 0x80, out_ptr, 0x40]
    staticcall          // [success]
    continue jumpi      // []

    // TODO: Custom revert message on failure
    0x00 dup1 revert

    continue:

    // Return stack:       []
}

/// @param `ptr_a` - Memory pointer to the input point `a` (64 bytes).
/// @param `scalar_ptr` - Memory pointer to the input `scalar` (32 bytes).
/// @param `out_ptr` - Memory pointer to write the result to (64 bytes).
/// @dev Calls the ecMul precompile with the G1 point `a` and the `scalar.
///      Writes 64 byte result to memory @ `out_ptr`.
///
/// - SAFETY:
///      Overwrites memory from [out_ptr:out_ptr+0x60]
#define macro SCALAR_MUL(ptr_a, scalar_ptr, out_ptr) = {
    // Input stack:        []

    // TODO: Can optimize if we ensure `ptr_a` and `scalar` are stored directly
    //       next to each other in memory to begin with.

    <scalar_ptr> mload  // [scalar]
    <ptr_a> mload       // [a_0, scalar]
    <ptr_a> 0x20 add    // [ptr_a + 0x20, a_0, scalar]
    mload               // [a_1, a_0, scalar]

    <out_ptr> 0x20 add  // [out_ptr + 0x20, a_1, a_0, scalar]
    mstore              // [a_0, scalar]
    0x00 mstore         // [scalar]
    <out_ptr> 0x40 add  // [out_ptr + 0x20, scalar]
    mstore              // []

    0x40 <out_ptr>      // [out_ptr, 0x40]
    0x60 dup2           // [out_ptr, 0x60, out_ptr, 0x40]
    // TODO: Sub 2000 from gas / add invalid op on failure?
    0x07 gas            // [gas, ec_add_precompile, out_ptr, 0x60, out_ptr, 0x40]
    staticcall          // [success]
    continue jumpi      // []

    // TODO: Custom revert message on failure
    0x00 dup1 revert
    
    continue:

    // Return stack:       []
}

// ...

/// @notice The verification key of the SNARK.
/// @dev This value is filled by the `huffv` binary, and it is packed with no
///      periphery information (i.e. "AlphaBetaGammaDeltaIC"). See the comment
///      of `MSTORE_VKEY` for more information.
#define table VKEY {
    {{placeholder}}
}

/// @notice Writes the verification key to memory at `ptr`
/// @dev The memory layout is as follows:
/// ╭──────┬─────────╮
/// │Offset│Contents │
/// ├──────┼─────────┤
/// │0x00  │ALPHA_0  │
/// ├──────┼─────────┤
/// │0x20  │ALPHA_1  │
/// ├──────┼─────────┤
/// │0x40  │BETA_0_0 │
/// ├──────┼─────────┤
/// │0x60  │BETA_0_1 │
/// ├──────┼─────────┤
/// │0x80  │BETA_1_0 │
/// ├──────┼─────────┤
/// │0xA0  │BETA_1_1 │
/// ├──────┼─────────┤
/// │0xC0  │BETA_1_2 │
/// ├──────┼─────────┤
/// │0xE0  │GAMMA_0_0│
/// ├──────┼─────────┤
/// │0x100 │GAMMA_0_1│
/// ├──────┼─────────┤
/// │0x120 │GAMMA_1_0│
/// ├──────┼─────────┤
/// │0x140 │GAMMA_1_1│
/// ├──────┼─────────┤
/// │0x160 │DELTA_0_0│
/// ├──────┼─────────┤
/// │0x180 │DELTA_0_1│
/// ├──────┼─────────┤
/// │0x1A0 │DELTA_1_0│
/// ├──────┼─────────┤
/// │0x1C0 │DELTA_1_1│
/// ├──────┼─────────┤
/// │0x1E0 │IC_0_0   │
/// ├──────┼─────────┤
/// │0x200 │IC_0_1   │
/// ├──────┼─────────┤
/// │0x220 │IC_1_0   │
/// ├──────┼─────────┤
/// │0x240 │IC_1_1   │
/// └──────┴─────────┘
#define macro MSTORE_VKEY(ptr) = {
    // Input stack:        []

    __tablestart(VKEY)  // [VKEY_start]
    __tablesize(VKEY)   // [VKEY_size, VKEY_start]
    <ptr>               // [0x00, VKEY_size, VKEY_start]
    codecopy            // []

    // Return stack:       []
}

/// @notice Verifies a SNARK proof.
/// @return `bool` True if proof is valid, false if not.
#define macro VERIFY_PROOF() = {
    MSTORE_VKEY(0x00)   // []
    [SNARK_SCALAR]      // [snark_scalar]

    // TODO
}
