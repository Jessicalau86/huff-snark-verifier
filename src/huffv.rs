use clap::Parser;
use serde::{Deserialize, Serialize};
use std::fmt;
use std::fmt::Formatter;
use std::fs::File;
use std::path::Path;

/// The Huff Verifier template contract
pub const HUFF_VERIFIER_CONTRACT: &str = include_str!("contracts/Verifier.huff");

/// Huff Verifier CLI Args
#[derive(Parser, Debug)]
#[clap(name = "huffv", version, about, long_about = None)]
pub struct HuffVerifier {
    /// The path to the verification key json file generated by snarkjs.
    pub path: Option<String>,

    /// If an output file is designated, the generator will save the verification
    /// contract to a file with filled-in constants as well as output the compiled bytecode.
    #[clap(short = 'o', long = "output")]
    source: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
struct VerificationKey {
    #[serde(rename(deserialize = "nPublic", serialize = "nPublic"))]
    pub n_public: u64,

    pub vk_alpha_1: Vec<String>,

    pub vk_beta_2: Vec<Vec<String>>,

    pub vk_gamma_2: Vec<Vec<String>>,

    pub vk_delta_2: Vec<Vec<String>>,

    pub vk_alphabeta_12: Vec<Vec<Vec<String>>>,

    #[serde(rename(deserialize = "IC", serialize = "IC"))]
    pub ic: Vec<Vec<String>>,
}

impl fmt::Display for VerificationKey {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).expect("Failed to serialize verification key.")
        )
    }
}

fn main() {
    let args = HuffVerifier::parse();

    if let Some(path) = args.path {
        let path = Path::new(&path);
        if path.exists() {
            match parse_verification_key(path) {
                Ok(key) => {
                    // TODO: Fill unassigned constants in Huff Verifier contract to generate a
                    //       key-specific SNARK verification contract, compiled, and output
                    //       the bytecode.
                    println!("{}", key);
                }
                Err(e) => eprintln!("{}", e),
            }
        } else {
            eprintln!("File does not exist!");
        }
    } else {
        eprintln!("No file path provided!");
    }
}

fn parse_verification_key(path: &Path) -> Result<VerificationKey, &'static str> {
    if let Ok(contents) = File::open(path) {
        Ok(serde_json::from_reader(contents)
            .expect("Error while deserializing verification key JSON."))
    } else {
        Err("Error reading file contents!")
    }
}
