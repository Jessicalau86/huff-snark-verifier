use clap::Parser;
use ibig::IBig;
use serde::{Deserialize, Serialize};
use std::fmt;
use std::fmt::Formatter;
use std::fs::File;
use std::path::Path;

/// The Huff Verifier template contract
pub const HUFF_VERIFIER_CONTRACT: &str = include_str!("contracts/Verifier.huff");

/// Huff SNARK Verifier CLI Args
#[derive(Parser, Debug)]
#[clap(name = "huffv", version, about, long_about = None)]
pub struct HuffVerifier {
    /// The path to the verification key json file generated by snarkjs.
    pub path: Option<String>,

    /// If an output file is designated, the generator will save the verification
    /// contract to a file with filled-in constants as well as output the compiled bytecode.
    #[clap(short = 'o', long = "output")]
    source: Option<String>,
}

#[derive(Serialize, Deserialize, Debug)]
struct VerificationKey {
    #[serde(rename(deserialize = "nPublic", serialize = "nPublic"))]
    pub n_public: u64,

    pub vk_alpha_1: Vec<String>,

    pub vk_beta_2: Vec<Vec<String>>,

    pub vk_gamma_2: Vec<Vec<String>>,

    pub vk_delta_2: Vec<Vec<String>>,

    pub vk_alphabeta_12: Vec<Vec<Vec<String>>>,

    #[serde(rename(deserialize = "IC", serialize = "IC"))]
    pub ic: Vec<Vec<String>>,
}

impl VerificationKey {
    pub fn to_packed(&self) -> String {
        format!(
            "0x{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}{}",
            Self::encode_num(&self.vk_alpha_1[0]),
            Self::encode_num(&self.vk_alpha_1[1]),
            Self::encode_num(&self.vk_beta_2[0][0]),
            Self::encode_num(&self.vk_beta_2[0][1]),
            Self::encode_num(&self.vk_beta_2[1][0]),
            Self::encode_num(&self.vk_beta_2[1][1]),
            Self::encode_num(&self.vk_gamma_2[0][0]),
            Self::encode_num(&self.vk_gamma_2[0][1]),
            Self::encode_num(&self.vk_gamma_2[1][0]),
            Self::encode_num(&self.vk_gamma_2[1][1]),
            Self::encode_num(&self.vk_delta_2[0][0]),
            Self::encode_num(&self.vk_delta_2[0][1]),
            Self::encode_num(&self.vk_delta_2[1][0]),
            Self::encode_num(&self.vk_delta_2[1][1]),
            Self::encode_num(&self.ic[0][0]),
            Self::encode_num(&self.ic[0][1]),
            Self::encode_num(&self.ic[1][0]),
            Self::encode_num(&self.ic[1][1]),
        )
    }

    /// Encodes a string that contains a 32 byte decimal number as a 32 byte hex string
    fn encode_num(n: &str) -> String {
        let num = IBig::from_str_radix(n, 10).expect("Failed to parse number.");
        num.in_radix(16).to_string()
    }
}

impl fmt::Display for VerificationKey {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}",
            serde_json::to_string_pretty(self).expect("Failed to serialize verification key.")
        )
    }
}

fn main() {
    let args = HuffVerifier::parse();

    if let Some(path) = args.path {
        let path = Path::new(&path);
        if path.exists() {
            match parse_verification_key(path) {
                Ok(key) => {
                    // TODO: Fill unassigned constants in Huff Verifier contract to generate a
                    //       key-specific SNARK verification contract, compiled, and output
                    //       the bytecode.
                    println!("{}", key);
                    println!("Packed: {}", key.to_packed());
                }
                Err(e) => eprintln!("{}", e),
            }
        } else {
            eprintln!("File does not exist!");
        }
    } else {
        eprintln!("No file path provided!");
    }
}

fn parse_verification_key(path: &Path) -> Result<VerificationKey, &'static str> {
    if let Ok(contents) = File::open(path) {
        Ok(serde_json::from_reader(contents)
            .expect("Error while deserializing verification key JSON."))
    } else {
        Err("Error reading file contents!")
    }
}
